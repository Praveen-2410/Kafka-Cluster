pipeline {
  agent any

  environment {
    NODE1 = "ec2-user@172.31.24.96"
    NODE2 = "ec2-user@172.31.30.30"
    NODE3 = "ec2-user@172.31.24.181"

    REMOTE_DIR = ""
    MULTI_NODE_REMOTE_DIR = ""
    KAFKA_IMAGE_REPO = ""
    KAFKA_BASE_IMAGE = ""
    GIT_BRANCH = ""
    GIT_REPO_URL = ""
    REMOTE_USER = ""
  }

  stages {
    stage('Load .env Variables') {
      steps {
        script {
          def envLines = readFile('.env').split('\n')
          for (line in envLines) {
            if (line && line.contains('=')) {
              def (key, value) = line.split('=', 2)
              env["${key.trim()}"] = value.trim()
            }
          }
          env.REMOTE_DIR = env.REMOTE_BASE_DIR
        }
      }
    }

    stage('Generate Dynamic Tag') {
      steps {
        script {
          def timestamp = sh(script: "date +%Y%m%d%H%M", returnStdout: true).trim()
          env.IMAGE_TAG = "npc-${env.KAFKA_IMAGE_REPO}-${timestamp}:latest"
        }
      }
    }

    stage('Checkout Git Repo') {
      steps {
        git branch: "${env.GIT_BRANCH}", url: "${env.GIT_REPO_URL}"
      }
    }

    stage('Inject Image Tag into File') {
      steps {
        dir(env.MULTI_NODE_REMOTE_DIR) {
          script {
            def envVars = readFile("${env.WORKSPACE}/.env").split('\n')
            def nexusHostLine = envVars.find { it.startsWith('NEXUS_HOST=') }
            def nexusHost = nexusHostLine?.split('=')[-1]?.trim()

            if (!nexusHost) {
              error "NEXUS_HOST not defined in .env file!"
            }

            env.IMAGE_FULL = "${nexusHost}/${env.KAFKA_IMAGE_REPO}/${env.IMAGE_TAG}"
            echo "Using image: ${env.IMAGE_FULL}"
            writeFile file: 'image-tag.txt', text: "${env.IMAGE_FULL}"
          }
        }
      }
    }

    stage('Build Docker Image') {
      steps {
        dir('Kafka-cluster') {
          sh 'docker build -t $(cat Multi-Node/image-tag.txt) .'
        }
      }
    }

    stage('Push Image to Nexus') {
      steps {
        dir(env.MULTI_NODE_REMOTE_DIR) {
          withCredentials([usernamePassword(credentialsId: 'nexus-creds-alt', usernameVariable: 'NEXUS_USER', passwordVariable: 'NEXUS_PASS')]) {
            sh '''
              IMAGE=$(cat image-tag.txt)
              echo "$NEXUS_PASS" | docker login $(echo $IMAGE | cut -d/ -f1) -u "$NEXUS_USER" --password-stdin
              docker push $IMAGE
            '''
          }
        }
      }
    }

    stage('Distribute Files to All Nodes') {
      steps {
        sshagent(credentials: ['ec2-ssh-key']) {
          script {
            def nodes = [env.NODE1, env.NODE2, env.NODE3]
            for (node in nodes) {
              sh """
                ssh -o StrictHostKeyChecking=no ${node} '
                  BASE_DIR="${env.REMOTE_DIR}"
                  if [ -d "$BASE_DIR" ]; then
                    sudo chown -R 1000:1000 "$BASE_DIR"
                  fi
                  mkdir -p "$BASE_DIR/data"
                  mkdir -p "$BASE_DIR/config/certs"
                  mkdir -p "$BASE_DIR/config/client-properties"
                  mkdir -p "$BASE_DIR/scripts"
                  chmod -R 755 "$BASE_DIR"
                '
                # Copy core files
                scp -o StrictHostKeyChecking=no \
                  Kafka-cluster/.env \
                  ${env.MULTI_NODE_REMOTE_DIR}/image-tag.txt \
                  ${env.MULTI_NODE_REMOTE_DIR}/docker-compose.yml.template \
                  ${node}:${env.REMOTE_DIR}/

                # Copy server properties    
                scp -o StrictHostKeyChecking=no \
                  ${env.MULTI_NODE_REMOTE_DIR}/config/server.properties.template \
                  ${node}:${env.REMOTE_DIR}/config/

                # Copy JAAS config files
                scp -o StrictHostKeyChecking=no \
                  ${env.MULTI_NODE_REMOTE_DIR}/config/kafka_jaas.conf \
                  ${env.MULTI_NODE_REMOTE_DIR}/config/kafka_admin_jaas.conf \
                  ${node}:${env.REMOTE_DIR}/config/

                # Copy client SSL and admin props
                scp -o StrictHostKeyChecking=no \
                  ${env.MULTI_NODE_REMOTE_DIR}/config/client-properties/client-ssl.properties \
                  ${env.MULTI_NODE_REMOTE_DIR}/config/client-properties/admin.properties \
                  ${node}:${env.REMOTE_DIR}/config/client-properties/

                # Copy certificate files
                scp -o StrictHostKeyChecking=no \
                  ${env.MULTI_NODE_REMOTE_DIR}/config/multi-node-certs/*.p12 \
                  ${node}:${env.REMOTE_DIR}/config/certs/

                # Copy scripts
                scp -o StrictHostKeyChecking=no \
                  ${env.MULTI_NODE_REMOTE_DIR}/scripts/* \
                  ${node}:${env.REMOTE_DIR}/scripts/

                # Set permissions
                ssh -o StrictHostKeyChecking=no ${node} '
                  chmod 644 ${env.REMOTE_DIR}/config/certs/*.p12
                  chmod +x ${env.REMOTE_DIR}/scripts/*.sh
                '
              """
            }
          }
        }
      }
    }

    stage('Generate Configs (envsubst)') {
      steps {
        sshagent(credentials: ['ec2-ssh-key']) {
          sh "ssh -o StrictHostKeyChecking=no ${env.NODE1} 'cd ${env.REMOTE_DIR} && bash scripts/generate-configs.sh 1'"
          sh "ssh -o StrictHostKeyChecking=no ${env.NODE2} 'cd ${env.REMOTE_DIR} && bash scripts/generate-configs.sh 2'"
          sh "ssh -o StrictHostKeyChecking=no ${env.NODE3} 'cd ${env.REMOTE_DIR} && bash scripts/generate-configs.sh 3'"
        }
      }
    }

    stage('Cluster ID Setup + Format') {
      steps {
        sshagent(credentials: ['ec2-ssh-key']) {
          script {
            def nodes = [env.NODE1, env.NODE2, env.NODE3]
            def existingClusterIds = []

            for (node in nodes) {
              def id = sh(
                script: "ssh -o StrictHostKeyChecking=no $node 'grep cluster.id ${env.REMOTE_DIR}/data/meta.properties | cut -d= -f2 || true'",
                returnStdout: true
              ).trim()
              existingClusterIds.add(id ?: '')
            }

            def uniqueIds = existingClusterIds.findAll { it }.unique()
            if (uniqueIds.size() == 1) {
              echo "All brokers already formatted with cluster ID: ${uniqueIds[0]}"
              return
            }

            if (uniqueIds.size() > 1) {
              echo "Mismatched cluster IDs found. Backing up and cleaning..."
              def timestamp = sh(script: "date +%Y%m%d%H%M%S", returnStdout: true).trim()
              for (node in nodes) {
                sh "ssh -o StrictHostKeyChecking=no $node 'mkdir -p ${env.REMOTE_DIR}/data-dir-backup-${timestamp} && cp -r ${env.REMOTE_DIR}/data/* ${env.REMOTE_DIR}/data-dir-backup-${timestamp}/ && rm -rf ${env.REMOTE_DIR}/data/*'"
              }
            }

            sh "docker pull ${env.KAFKA_BASE_IMAGE}"
            def clusterId = sh(script: "docker run --rm ${env.KAFKA_BASE_IMAGE} /opt/kafka/bin/kafka-storage.sh random-uuid", returnStdout: true).trim()
            echo "Generated Cluster ID: ${clusterId}"

            for (node in nodes) {
              sh """
                ssh -o StrictHostKeyChecking=no $node '
                  docker run --rm \
                    -v ${env.REMOTE_DIR}/config/server.properties:/opt/kafka/config/kraft/server.properties \
                    -v ${env.REMOTE_DIR}/data:/var/lib/kafka/data \
                    ${env.KAFKA_BASE_IMAGE} \
                    /opt/kafka/bin/kafka-storage.sh format -t $clusterId -c /opt/kafka/config/kraft/server.properties
                '
              """
            }
          }
        }
      }
    }

    stage('Start Kafka Containers') {
      steps {
        sshagent(credentials: ['ec2-ssh-key']) {
          withCredentials([usernamePassword(credentialsId: 'nexus-creds-alt', usernameVariable: 'NEXUS_USER', passwordVariable: 'NEXUS_PASS')]) {
            script {
              def nodes = [env.NODE1, env.NODE2, env.NODE3]
              for (node in nodes) {
                sh """#!/bin/bash
ssh -o StrictHostKeyChecking=no $node \\
NEXUS_USER='$NEXUS_USER' NEXUS_PASS='$NEXUS_PASS' bash -s <<'EOF'
set -e
IMAGE=\$(cat ${env.REMOTE_DIR}/image-tag.txt)
REGISTRY=\$(echo \$IMAGE | cut -d/ -f1)
echo "IMAGE: \$IMAGE"
echo "REGISTRY: \$REGISTRY"
echo "Logging in..."
echo "\$NEXUS_PASS" | docker login \$REGISTRY -u "\$NEXUS_USER" --password-stdin
cd ${env.REMOTE_DIR}
docker-compose -f docker-compose.yml up -d
EOF
"""
              }
            }
          }
        }
      }
    }

    stage('Verify Initial Cluster Health') {
      steps {
        sshagent(credentials: ['ec2-ssh-key']) {
          script {
            def maxRetries = 6
            def sleepSeconds = 10
            def success = false

            for (int i = 1; i <= maxRetries; i++) {
              echo "ðŸ” Attempt $i: Checking cluster health..."
              def result = sh(
                script: """
                ssh -o StrictHostKeyChecking=no ${env.NODE1} 'cd ${env.REMOTE_DIR}/scripts && bash verify-cluster-health.sh'",
                returnStatus: true
              )

              if (result == 0) {
                echo "âœ… Cluster is healthy."
                success = true
                break
              } else {
                echo "âŒ Cluster not healthy. Retrying in ${sleepSeconds}s..."
                sleep sleepSeconds
              }
            }

            if (!success) {
              error "ðŸ›‘ Cluster did not become healthy after ${maxRetries} attempts!"
            }
          }
        }
      }
    }

    stage('Setup Admin User') {
      steps {
        sshagent(credentials: ['ec2-ssh-key']) {
          sh "ssh -o StrictHostKeyChecking=no ${env.NODE1} 'cd ${env.REMOTE_DIR}/scripts && bash setup-admin-user.sh'"
        }
      }
    }

    stage('Update super.users and Restart Brokers') {
      steps {
        sshagent(credentials: ['ec2-ssh-key']) {
          script {
            def nodes = [env.NODE1, env.NODE2, env.NODE3]
            for (node in nodes) {
            sh '''#!/bin/bash
              ssh -o StrictHostKeyChecking=no ''' + node + ''' <<'EOF'
              grep -q "^super.users=" $REMOTE_DIR/config/server.properties &&
              sed -i "s|^super.users=.*|super.users=User:admin;User:ANONYMOUS|" $REMOTE_DIR/config/server.properties ||
              echo "super.users=User:admin;User:ANONYMOUS" >> $REMOTE_DIR/config/server.properties

              grep -q "^allow.everyone.if.no.acl.found=" $REMOTE_DIR/config/server.properties &&
              sed -i "s|^allow.everyone.if.no.acl.found=.*|allow.everyone.if.no.acl.found=false|" $REMOTE_DIR/config/server.properties ||
              echo "allow.everyone.if.no.acl.found=false" >> $REMOTE_DIR/config/server.properties

              docker-compose -f $REMOTE_DIR/docker-compose.yml restart
            EOF
            '''
            }
          }
        }
      }
    }

    stage('Re-verify Cluster Health Post-Restart') {
      steps {
        sshagent(credentials: ['ec2-ssh-key']) {
          script {
            def maxRetries = 6
            def sleepSeconds = 10
            def success = false

            for (int i = 1; i <= maxRetries; i++) {
              echo "ðŸ” Attempt $i: Re-checking cluster health..."
              def result = sh(
                script: "ssh -o StrictHostKeyChecking=no ${env.NODE1} 'cd ${env.REMOTE_DIR}/scripts && bash verify-cluster-health.sh'",
                returnStatus: true
              )

              if (result == 0) {
                echo "âœ… Cluster is healthy after restart."
                success = true
                break
              } else {
                echo "âŒ Still unhealthy. Retrying in ${sleepSeconds}s..."
                sleep sleepSeconds
              }
            }

            if (!success) {
              error "ðŸ›‘ Cluster not healthy after restart!"
            }
          }
        }
      }
    }

    stage('Create Users, Topics & ACLs') {
      steps {
        sshagent(credentials: ['ec2-ssh-key']) {
          sh "ssh -o StrictHostKeyChecking=no ${env.NODE1} 'cd ${env.REMOTE_DIR}/scripts && bash create_users_topic.sh'"
        }
      }
    }

    stage('Deployment Summary') {
      steps {
        echo '''
        Multi-Node Kafka Cluster Deployed Successfully
        '''
      }
    }
  }
}
